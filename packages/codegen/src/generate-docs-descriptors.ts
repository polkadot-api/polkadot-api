import {
  getChecksumBuilder,
  getLookupFn,
} from "@polkadot-api/metadata-builders"
import { getDocsTypesBuilder } from "@/types-builder"
import { knownTypes } from "./known-types"
import { UnifiedMetadata } from "@polkadot-api/substrate-bindings"

export type FileTree = {
  [key: string]: string | FileTree
}

const paths = {
  client: "polkadot-api",
  types: "types",
}

export async function generateDocsDescriptors(
  key: string,
  metadata: UnifiedMetadata,
): Promise<FileTree> {
  const lookup = getLookupFn(metadata)
  const checksumBuilder = getChecksumBuilder(lookup)
  const docsTypesBuilder = getDocsTypesBuilder(
    lookup,
    knownTypes,
    checksumBuilder,
  )

  const getClientImports = () => [
    "StorageDescriptor",
    "PlainDescriptor",
    "TxDescriptor",
    "RuntimeDescriptor",
    "Enum",
    "_Enum",
    "Binary",
    "FixedSizeBinary",
    "FixedSizeArray",
    "QueryFromPalletsDef",
    "TxFromPalletsDef",
    "EventsFromPalletsDef",
    "ErrorsFromPalletsDef",
    "ConstFromPalletsDef",
    "ViewFnsFromPalletsDef",
    "SS58String",
    "ResultPayload",
    "TxCallData",
    ...docsTypesBuilder.getClientFileImports(),
  ]

  const storageOutput = await buildStorage(
    metadata,
    docsTypesBuilder,
    getClientImports,
  )

  const runtimeCallsOutput = await buildRuntimeCalls(
    metadata,
    docsTypesBuilder,
    getClientImports,
  )
  const errorsOutput = await buildErrors(
    metadata,
    docsTypesBuilder,
    getClientImports,
  )
  const constantsOutput = await buildConstants(
    metadata,
    docsTypesBuilder,
    getClientImports,
  )
  const eventsOutput = await buildEvents(
    metadata,
    docsTypesBuilder,
    getClientImports,
  )
  const callsOutput = await buildCalls(
    metadata,
    docsTypesBuilder,
    getClientImports,
  )
  const viewFnsOutput = await buildViewFns(
    metadata,
    docsTypesBuilder,
    getClientImports,
  )

  const descriptorsTypesFileContent =
    `import {\n  ${getClientImports().join(",\n  ")}\n} from "${paths.client}";\n` +
    docsTypesBuilder
      .getDescriptorsTypes()
      .map((variable) => {
        return `export type ${variable.name} = ${variable.type};`
      })
      .join("\n") +
    `
/**
 * This is a special type that we're using only in this docs.
 * It's not present in descriptors generated by polkadot-api, and only used for 
 * marking circular types, if they aren't a known type.  
 */
export type __Circular = any;
`

  const hasSection = {
    storage: storageOutput.index !== "",
    runtimeCalls: runtimeCallsOutput.index !== "",
    errors: errorsOutput.index !== "",
    constants: constantsOutput.index !== "",
    events: eventsOutput.index !== "",
    calls: callsOutput.index !== "",
    viewFns: viewFnsOutput.index !== "",
  }
  const index = getIndexFileDocs({ chainName: key, hasSection })

  return {
    index,
    types: descriptorsTypesFileContent,
    Storage: storageOutput,
    RuntimeCalls: runtimeCallsOutput,
    Errors: errorsOutput,
    Constants: constantsOutput,
    Events: eventsOutput,
    Transactions: callsOutput,
    ViewFunctions: viewFnsOutput,
  }
}

const buildEnumObj = <T>(
  metadata: UnifiedMetadata,
  val: number | undefined,
  cb: (name: string, docs: string[]) => T,
): Record<string, T> => {
  if (val === undefined) return {}

  const lookup = metadata.lookup[val]
  if (lookup.def.tag !== "variant") throw null
  return Object.fromEntries(
    lookup.def.value.map((x) => {
      return [x.name!, cb(x.name, x.docs)]
    }),
  )
}

async function buildErrors(
  metadata: UnifiedMetadata,
  docsTypesBuilder: ReturnType<typeof getDocsTypesBuilder>,
  getClientImports: () => string[],
): Promise<FileTree> {
  const errors = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: buildEnumObj(metadata, pallet.errors?.type, (name, docs) => {
            return {
              type: `PlainDescriptor<${docsTypesBuilder.buildError(
                pallet.name,
                name,
              )}>`,
              docs,
            }
          }),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports(),
        },
      ]
    }),
  )

  return buildTypeFolder(errors, getClientImports)
}

async function buildConstants(
  metadata: UnifiedMetadata,
  docsTypesBuilder: ReturnType<typeof getDocsTypesBuilder>,
  getClientImports: () => string[],
): Promise<FileTree> {
  const constants: FolderFileInput = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: Object.fromEntries(
            pallet.constants?.map(({ name, docs }) => {
              const type = `PlainDescriptor<${docsTypesBuilder.buildConstant(
                pallet.name,
                name,
              )}>`
              return [
                name,
                {
                  type,
                  docs,
                },
              ]
            }) ?? [],
          ),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports(),
        },
      ]
    }),
  )

  return buildTypeFolder(constants, getClientImports)
}

async function buildEvents(
  metadata: UnifiedMetadata,
  docsTypesBuilder: ReturnType<typeof getDocsTypesBuilder>,
  getClientImports: () => string[],
): Promise<FileTree> {
  const events: FolderFileInput = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: buildEnumObj(metadata, pallet.events?.type, (name, docs) => {
            return {
              type: `PlainDescriptor<${docsTypesBuilder.buildEvent(
                pallet.name,
                name,
              )}>`,
              docs,
            }
          }),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports(),
        },
      ]
    }),
  )

  return buildTypeFolder(events, getClientImports)
}

async function buildCalls(
  metadata: UnifiedMetadata,
  docsTypesBuilder: ReturnType<typeof getDocsTypesBuilder>,
  getClientImports: () => string[],
): Promise<FileTree> {
  const calls: FolderFileInput = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: buildEnumObj(metadata, pallet.calls?.type, (name, docs) => {
            return {
              type: `TxDescriptor<${docsTypesBuilder.buildCall(
                pallet.name,
                name,
              )}>`,
              docs,
            }
          }),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports(),
        },
      ]
    }),
  )

  return buildTypeFolder(calls, getClientImports)
}

async function buildRuntimeCalls(
  metadata: UnifiedMetadata,
  docsTypesBuilder: ReturnType<typeof getDocsTypesBuilder>,
  getClientImports: () => string[],
): Promise<FileTree> {
  const runtimeCalls = Object.fromEntries(
    metadata.apis.map((api) => [
      api.name,
      {
        docs: api.docs,
        values: Object.fromEntries(
          api.methods.map((method) => {
            const { args, value } = docsTypesBuilder.buildRuntimeCall(
              api.name,
              method.name,
            )
            return [
              method.name,
              {
                type: `RuntimeDescriptor<${args}, ${value}>`,
                docs: method.docs,
              },
            ]
          }),
        ),
        descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports(),
      },
    ]),
  )
  return buildTypeFolder(runtimeCalls, getClientImports)
}

async function buildViewFns(
  metadata: UnifiedMetadata,
  docsTypesBuilder: ReturnType<typeof getDocsTypesBuilder>,
  getClientImports: () => string[],
): Promise<FileTree> {
  const viewFns = Object.fromEntries(
    metadata.pallets.map((pallet) => [
      pallet.name,
      {
        docs: pallet.docs,
        values: Object.fromEntries(
          pallet.viewFns.map((fn) => {
            const { args, value } = docsTypesBuilder.buildViewFn(
              pallet.name,
              fn.name,
            )
            return [
              fn.name,
              {
                type: `RuntimeDescriptor<${args}, ${value}>`,
                docs: fn.docs,
              },
            ]
          }),
        ),
        descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports(),
      },
    ]),
  )
  return buildTypeFolder(viewFns, getClientImports)
}

async function buildStorage(
  metadata: UnifiedMetadata,
  docsTypesBuilder: ReturnType<typeof getDocsTypesBuilder>,
  getClientImports: () => string[],
): Promise<FileTree> {
  const storage: FolderFileInput = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: Object.fromEntries(
            pallet.storage?.items.map((item) => {
              const { name, docs, modifier } = item

              if (pallet.name === "System" && name === "Events") {
                return [
                  "Events",
                  {
                    type: `StorageDescriptor<[], any, ${!modifier}, "never">`,
                    docs: [
                      ...docs,
                      "",
                      " Due to readability reasons, return type of Events item is omitted in this documentation",
                    ],
                  },
                ]
              }

              const { args, payload, opaque } = docsTypesBuilder.buildStorage(
                pallet.name,
                name,
              )
              return [
                name,
                {
                  type: `StorageDescriptor<${args}, ${payload}, ${!modifier}, ${opaque}>`,
                  docs,
                },
              ]
            }) ?? [],
          ),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports(),
        },
      ]
    }),
  )

  return buildTypeFolder(storage, getClientImports)
}

type FolderFileInput = {
  [p: string]: {
    docs: string[]
    descriptorsTypesImports: string[]
    values: { [p: string]: { type: string; docs: string[] } }
  }
}

function buildTypeFolder(
  input: FolderFileInput,
  getClientImports: () => string[],
): { [p: string]: string } {
  const output: { [p: string]: string } = {}

  output["index"] = ""

  for (const [
    section,
    { docs, values, descriptorsTypesImports },
  ] of Object.entries(input)) {
    if (Object.keys(values).length === 0) continue

    const sectionDocs =
      docs.length > 0
        ? `
/**
${docs.map((doc: string) => ` *${doc}`).join("\n")}
 * @packageDocumentation
 */\n\n
`
        : ""

    const imports = `
import {\n  ${getClientImports().join(",\n  ")}\n} from "${paths.client}";\n
import {\n  ${descriptorsTypesImports.join(",\n  ")}\n} from "../${paths.types}";
  `

    output[section] =
      sectionDocs +
      imports +
      Object.entries(values)
        .map(
          ([typeName, typeDef]) =>
            formatDocs(typeDef.docs) +
            // splitting type declaration and export allows us to curcumvent potential
            // collisions between imports and type names
            `
type ${section}_${typeName} = ${typeDef.type};
export {${section}_${typeName} as ${typeName}};`,
        )
        .join("\n")

    output["index"] += `export * as ${section} from "./${section}";\n`
  }

  return output
}

function formatDocs(docs: string[]): string {
  return `/**
${docs.map((doc: string) => ` *${doc}`).join("\n")}
*/
`
}

function getIndexFileDocs({
  chainName,
  hasSection,
}: {
  chainName: string
  hasSection: {
    storage: boolean
    runtimeCalls: boolean
    errors: boolean
    constants: boolean
    events: boolean
    calls: boolean
    viewFns: boolean
  }
}): string {
  return `
/**
 * This is generated documentation for TypedAPI decriptors for **${chainName}** chain  
 * 
 * **TypedApi calls** section describes apis that are available via calls like  
 * \`\`\`ts
 * api.tx.XcmPallet.limited_teleport_assets({...})
 * \`\`\`
 * Where \`api\` is returned by \`client.getTypedApi(${chainName})\` call  
 *
 * Each section has APIs grouped by pallet name  
 * 
 * **Types** represent TypeScript types that are to be imported
 * from \`@polkadot-api/descriptors\`:  
 * \`\`\`ts
 * import { XcmVersionedLocation, XcmV3Junctions } from "@polkadot-api/descriptors"
 * \`\`\`
 * 
 * @see [papi.how](https://papi.how/) for generic documentation on \`polkadot-api\`
 * 
 * @packageDocumentation
 */

${
  hasSection.storage
    ? `/**
 * Storage queries reference
 * 
 * Each item described here is a
 *\`StorageDescriptor<Args, ReturnType, Optional, Opaque>\`  
 * For example, \`System.Account\` is of type
 * \`\`\`ts
 * Account: StorageDescriptor<[Key: SS58String], {
 *     consumers: number;
 *     data: {
 *         flags: bigint;
 *         free: bigint;
 *         frozen: bigint;
 *         reserved: bigint;
 *     };
 *     nonce: number;
 *     providers: number;
 *     sufficients: number;
 * }, false, "never">
 * \`\`\`
 * and can be queried via
 * \`\`\`ts
 * const account = await api.query.System.Account.getValue("<AccountId>")
 * console.log(account.data.free)
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/queries) on storage queries for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Storage from "./Storage";

`
    : ""
}
${
  hasSection.constants
    ? `/**
 * Constants reference
 * 
 * Each item described here is a \`PlainDescriptor<T>\`  
 * 
 * For example, \`System.Version\` is of type
 * \`\`\`ts
 * Version: PlainDescriptor<{
 *     apis: [FixedSizeBinary<8>, number][];
 *     authoring_version: number;
 *     impl_name: string;
 *     impl_version: number;
 *     spec_name: string;
 *     spec_version: number;
 *     state_version: number;
 *     transaction_version: number;
 * }>
 * \`\`\`
 * and can be queried via
 * \`\`\`ts
 * const version = await typedApi.constants.System.Version()
 * console.log(version.spec_version)
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/constants) on constants for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Constants from "./Constants";

`
    : ""
}
${
  hasSection.errors
    ? `/**
 * Errors
 * 
 * This section is temporarily commented out, 
 * as errors aren't documented in papi yet
 * https://github.com/polkadot-api/polkadot-api-docs/issues/25 
 * 
 * @namespace
 * @category Types
 */
// export * as Errors from "./Errors";

`
    : ""
}
${
  hasSection.calls
    ? `/**
 * Transactions reference
 * 
 * Each item described here is a \`TxDescriptor<T>\`, where \`T\` describes
 * all the arguments required by the extrinsic
 * 
 * For example, \`Balances.transfer_keep_alive\` is of type
 * \`\`\`ts
 * transfer_keep_alive: TxDescriptor<{
 *     dest: MultiAddress;
 *     value: bigint;
 * }>
 * \`\`\`
 * and can be used like this
 * \`\`\`ts
 * const tx = api.tx.Balances.transfer_keep_alive({
 *   dest: MultiAddress.Id(userAddress),
 *   value: 10n ** 10n, // 1 DOT
 * })
 * await tx.signAndSubmit(signer)
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/tx) on transactions for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Transactions from "./Transactions";

`
    : ""
}
${
  hasSection.events
    ? `/**
 * Events
 * 
 * Each item described here is a \`PlainDescriptor<T>\`  
 * 
 * For example, \`System.NewAccount\` is of type
 * \`\`\`ts
 * NewAccount: PlainDescriptor<{ "account": SS58String }>;
 * \`\`\`
 * and can be queried via
 * \`\`\`ts
 * const newAccountEvents = await api.event.System.NewAccount.pull()
 * newAccountEvents.forEach(newAccount => {
 *  const address: SS58String = newAccount.payload.account
 *  console.log(address)
 * })
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/events) on events for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Events from "./Events";

`
    : ""
}
${
  hasSection.viewFns
    ? `/**
 * View Functions
 * 
 * Each item described here is a \`RuntimeDescriptor<Args, ReturnType>\`
 * 
 * For example, \`Proxy.is_superset\` is of type
 * \`\`\`ts
 * is_superset: RuntimeDescriptor<[to_check: ProxyType, against: ProxyType], boolean>
 * \`\`\`
 * and can be called like this:
 * \`\`\`ts
 *  const isSuperset = await api.view.Proxy.is_superset(Enum("Any"), Enum("NonTransfer"))
 *  console.log(isSuperset)
 * })
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/view) on view functions for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as ViewFunctions from "./ViewFunctions";

`
    : ""
}
${
  hasSection.runtimeCalls
    ? `/**
 * Runtime calls
 * 
 * Each item described here is a \`RuntimeDescriptor<Args, ReturnType>\`
 * 
 * For example, \`Metadata.metadata_at_version\` is of type
 * \`\`\`ts
 * metadata_at_version: RuntimeDescriptor<[version: number], Binary | undefined>
 * \`\`\`
 * and can be called like this:
 * \`\`\`ts
 *  const metadata = await api.apis.Metadata.metadata_at_version(15)
 *  console.log(metadata?.asHex())
 * })
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/apis) on runtime APIs for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as RuntimeCalls from "./RuntimeCalls";

`
    : ""
}
/**
 * Descriptors types
 * 
 * These are the types used in API calls and imported out of descriptors  
 * 
 * For example, \`XcmVersionedLocation\` is an enum:
 * \`\`\`ts
 * XcmVersionedLocation: Enum<{
 *     V2: { ... };
 *     V3: {
 *         interior: XcmV3Junctions;
 *         parents: number;
 *     };
 *     V4: { ... };
 * }>
 * \`\`\`
 * and can be used like this
 * \`\`\`ts
 * import { XcmVersionedLocation, XcmV3Junctions } from "@polkadot-api/descriptors"
 * await typedApi.tx.XcmPallet.limited_teleport_assets({
      dest: XcmVersionedLocation.V3({
        parents: 0,
        interior: XcmV3Junctions.X1(XcmV3Junction.Parachain(parachain_id)),
      }),
 * \`\`\`
 * 
 * @namespace
 * @category Types
 */
export * as Types from "./types";`
}
